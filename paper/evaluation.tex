\section{Evaluation}
\label{sec:evaluation}

We evaluate \Mesh in three ways.  We show that under an adversarial
program, \Mesh is able to recover from fragmentation much better than
other allocators.  As a case-study, we run Firefox under \Mesh and
identify that \Mesh may be able to recover ~10\% of overall memory
using \Mesh.  Finally, we run several benchmarks from the SPEC 2006
benchmark suite and show that \Mesh performs efficiently.

\subsection{High-fragmentation Performance}

Fragmentation happens when a sparse number of small objects requires
many pages of memory from the operating system, and we test \Mesh
under an adversarial program that attempts to achieve high
fragmentation.

Our adversarial program works as follows: It allocates 128 MiB of
512-byte objects, and then it frees every other object.  Next, it
allocates 64 MiB of 1024-byte objects, and frees every other object.
At the end of the program, the object has references to 128 MiB of
`live' allocations.  This program forces fragmentation, as there is no
consecutive space available after freeing every other allocation to
satisfy any new allocation.

When run under both TCMalloc and GNU libc's default malloc, the
application has a resident-set size of over 255 MiB, a memory blowup
of almost 2x due entirely to fragmentation.

When run under \Mesh where \Mesh is explicitly asked to mesh at the
end of the allocation cycle, memory usage drops to under 155 MiB, only
1.2x more than the application is referencing and a relative savings
of 100 MiB.

\subsection{Firefox}

Firefox is a web browser, a modern dynamic application that uses
between hundreds of megabytes and gigabytes of memory under standard
usage.  Firefox includes a Just-in-time compiler for JavaScript, and
manages memory for JavaScript objects on its own, in an isolated,
compacting, garbage collected heap.  Firefox does use the system (or a
bundled) allocator for significant portions of its allocated memory,
especially the Document Object Model and non-JS objects.

We run Firefox under \Mesh and are able to write the internal state of
\Mesh's data structures (such as the MiniHeap bitmap) to disk.  We
analyze these and show that the potential memory savings from being
able to mesh near-optimally is a reduction of 25\% the amount of
memory used for small objects (the objects we manage with MiniHeaps
and store in a meshable region of memory), which could translate to
~10\% overall reduction in memory usage for Firefox.

%% Additionally, we are able to show the occupancy of spans across
%% different size classes, as seen in Figure~\ref{fig:ff-occupancy}.
%% This data was reported after opening Firefox, navigating to Amazon,
%% and scrolling to the bottom of the page.  Intuitively, as the string
%% length increases (for smaller size classes), average occupancy
%% decreases.
