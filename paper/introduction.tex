\section{Introduction}
\label{sec:introduction}

In unmanaged languages like C and C++ the memory addresses of objects
are directly exposed to the program, and as a result objects cannot be
relocated.  These languages let programmers store addresses in
integers, perform arithmetic on addresses, write them to and from
pipes, and convert integers into addresses.  Given such an adversarial
environment, a runtime system can not guarantee that it can identify
all object references at any given point in time.  Without precisely
identifying \textit{all} references objects can not safely be
relocated, as all locations that point to a moved object need to be
updated for the program to continue executing correctly.

Because objects can not be relocated, memory allocators for these
languages can not perform compaction and thus programs may suffer from
fragmentation.  Fragmentation is a result of the fact that while a
user's program manages memory at the granularity of \textit{bytes},
operating systems manage memory at the level of \textit{pages} (4 KiB
on most contemporary architectures).  Fragmentation occurs when a
small number of program objects require the reservation of a
corresponding large number of pages from the operating system.
Fragmentation can result in a program requiring orders of magnitude
more memory from the operating system than is required by the
semantics of the program.

Fragmentation is important because it exacerbates memory pressure --
one of the scarcest resources on modern computing devices.  70 percent
of Google Chrome crashes on low-RAM Android devices are caused by
Chrome running out of memory when attempting to display the
page~\cite{hara:whymemory}.  Embedded systems designed for the
Internet-of-Things (IoT), such as the Raspberry Pi Zero W, ship with
wireless networking, 3D graphics, and complete operating system stacks
but only hundreds of megabytes of memory~\cite{rpi:zero}.

Fragmentation has been widely
studied~\cite{johnstone:1998:fragmentation} and solved for managed
languages with \textit{moving
  compaction}~\cite{hansen:1969:compaction,fenichel:1969:compaction}
in the late 1960s.  Compaction minimizes fragmentation by moving live
objects close together.  Contemporary runtimes like the Hotspot
JVM~\cite{microystems2006memory}, The .NET
VM~\cite{microsoft:dotnet-gc}, the SpiderMonkey JavaScript
VM~\cite{mozilla:spidermonkey-compaction} and others implement moving
compaction as part of their garbage collection algorithms.

We present \Mesh, the first runtime system to bring precise compaction
to unmanaged languages like C and C++.  \Mesh uses randomization to
provably bound the impact of fragmentation with high probability.

\subsection{Contributions}
\label{sec:contributions}

This paper makes the following contributions:

\begin{itemize}
\item It introduces the concept of \textbf{meshing}, a mechanism that
  provides \textit{compaction without relocation} for unmanaged
  languages.  Meshing eliminates memory fragmentation in languages
  like C and C++ with high probability, and we identify analytic
  bounds on the savings possible and achievable.
\item It presents \textbf{\Mesh}, a runtime system and memory
  allocator that delivers compaction without relocation for binaries
  compiled from unmanaged languages like C, C++ and Rust.  We evaluate
  \Mesh's performance empirically and analytically.
  % TODO: mention evaluation results
\end{itemize}

The rest of this paper is organized as follows.
Section~\ref{sec:meshing} introduces the concept of meshing and show
how our approach reduces fragmentation in a representative unmanaged
program.  Section~\ref{sec:allocator} details \Mesh's efficient memory
allocator.  Section~\ref{sec:theory} presents the theoretical results
that make meshing efficient and
practical. Section~\ref{sec:evaluation} provides an empirical
evaluation of \Mesh, and section~\ref{sec:discussion} discusses how
several classes of applications would benefit from deeper integration
with \Mesh.  Finally, section~\ref{sec:related-work} discusses related work, and
section~\ref{sec:conclusion} concludes this paper.
