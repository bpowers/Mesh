\section{Introduction}
\label{sec:introduction}

C/C++ addresses are available and frequently used. Can't move objects around.

Therefore, can't perform compaction.

Classical bounds: worst-case, tons of fragmentation~\cite{robson1977worst}.

Empirical studies suggest fragmentation is low (Wilson cite~\cite{Johnstone:1998:MFP:286860.286864}) but the
worst-case is still a problem. In real-time settings, can't rely on
malloc and must either pre-allocate all memory into pools, or rely on
compacting garbage collection.

Connect up to conservative garbage collection (cite Boehm); note
limited ability to reduce fragmentation (perhaps in related
work~\cite{Rodriguez-Rivera:1998:NNG:286860.286869}).

We present a counter-intuitive result. \emph{Meshing memory
  management}. Explain key insight (keep virtual addresses while
compacting). We mesh together pages when the objects on the page don't
have overlapping offsets. We re-map the virtual address to point to
the merged physical page, and discard the old physical page.

Clearly, this can't always work. In the worst case, an adversarial
program could fill every page with a single object at the same offset
(e.g., at the start of the page), which would thwart any attempts at
meshing.

We resolve this problem by using a randomized algorithm that makes
such adversarial situations extremely unlikely. We show analytically
that our algorithm guarantees that it can achieve significant
compression when there is available space with high probability.

Demonstrate implementation.

Results.

Outline of rest of paper.
