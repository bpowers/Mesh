# Copyright 2018 Bobby Powers. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

import argparse
from sys import stdout, stderr, argv
from subprocess import Popen, PIPE
from os import environ, getcwd
from datetime import datetime
from os.path import dirname, samefile, join
from shutil import copyfile

LOCAL_PKGCONFIG = '/usr/local/lib/pkgconfig'
PKG_PATH = 'PKG_CONFIG_PATH'

# workaround because apparently the local/bin pkg-config path isn't in
# the system package-config search path, like I think it is on debian-
# based systems.
if PKG_PATH in environ:
    new_path = '%s:%s' % (LOCAL_PKGCONFIG, environ[PKG_PATH])
else:
    new_path = LOCAL_PKGCONFIG
environ[PKG_PATH] = new_path


def slurp(fname):
    with open(fname, 'r') as f:
        return f.read()


def run_cmd(cmd, effect='stdout'):
    '''
    Runs a shell command, waits for it to complete, and returns stdout.
    '''
    with open('/dev/null', 'w') as dev_null:
        call = Popen(cmd, shell=True, stdout=PIPE, stderr=dev_null)
        ret, _ = call.communicate()
        if effect == 'stdout':
            return ret
        else:
            return call.returncode


def exe_available(cmd):
    '''
    Returns true if the command is found on the path.
    '''
    path = run_cmd('which %s' % (cmd))
    return len(path) > 0


def _new_env():
    return {
        'cflags': '',
        'ldflags': '',
        'libs': '',
    }

help_text = '''Usage: ./configure [ OPTIONS ]
Configure the build system for Mesh.

Options:

  --help           display this help and exit
  --debug          build with debugging symbols
  --coverage       build with gcov profiling support
  --clangcov       build with clang profiling support
  --(no-)optimize  build with heavy optimizations
  --mingw          cross-compiling under mingw32

Report bugs to <bpowers@cs.umass.edu>.
'''

class ConfigBuilder:
    def __init__(self):
        self.env = _new_env()
        self.defs = {}
        self.config('year', str(datetime.now().year))

        parser = argparse.ArgumentParser(description='Configure the mesh build.')
        parser.add_argument('--debug', action='store_true', default=True,
                            help='build with debugging symbols')
        parser.add_argument('--no-debug', action='store_false', dest='debug',
                            help='build with debugging symbols')
        parser.add_argument('--optimize', action='store_true', default=True,
                            help='build with optimizations (default)')
        parser.add_argument('--no-optimize', action='store_false', dest='optimize',
                            help='build without optimizations')
        parser.add_argument('--gcov', action='store_true', default=False,
                            help='build with gcov profiling support')
        parser.add_argument('--clangcov', action='store_true', default=False,
                            help='build with gcov profiling support')

        args = parser.parse_args()

        self.debug_build = args.debug
        self.gcov_build = args.gcov
        self.clangcov_build = args.clangcov
        self.optimize_build = args.optimize

        self.pkg_config = 'pkg-config'


    def config(self, key, val):
        self.defs[key] = '"' + val + '"'


    def config_int(self, key, val):
        self.defs[key] = val


    def require(self, lib='', program=None):
        if not program:
            program = self.pkg_config

        env = self.env
        path = run_cmd('which %s' % (program))
        if len(path) is 0:
            stderr.write('required program "%s" not found.\n' % program)
            exit(1)

        # single-quote stuff for pkg-config
        if len(lib) > 0:
            lib = "'%s'" % lib

        if len(lib) > 0:
            # assumes a pkg-config-like program
            ret = run_cmd('%s --exists %s' % (program, lib), 'returncode')
            if ret != 0:
                stderr.write('required library %s not found.\n' % lib)
                exit(1)

        for info in ['cflags', 'libs', 'ldflags']:
            if info in env:
                existing = env[info]
            else:
                existing = ''
            new = run_cmd('%s --%s %s' % (program, info, lib)).strip()
            env[info] = existing + ' ' + new

    def generate(self, mk_config='config.mk', header_config='src/config.h'):
        if self.gcov_build or self.clangcov_build:
            self.append('cflags', '-D_PROF')

        with open(mk_config, 'w') as config:
            for info in sorted(self.env.keys()):
                values = self.env[info].strip()
                config.write('%s := %s\n' % (info.upper(),
                                             values))

        with open(header_config, 'w') as config:
            config.write('// -*- mode: c++; c-basic-offset: 2; indent-tabs-mode: nil -*-\n')
            config.write('// auto-generated by ./configure, do not edit.\n\n')
            config.write('#pragma once\n')
            config.write('#ifndef MESH__CONFIG_H\n')
            config.write('#define MESH__CONFIG_H\n\n')
            for var in sorted(self.defs.keys()):
                value = self.defs[var].strip()
                config.write('#define %s %s\n' %
                             (var.upper().replace('-', '_'), value))
            config.write('\n#endif // MESH__CONFIG_H\n')

        src_dir = dirname(argv[0])
        if not samefile(src_dir, getcwd()):
            copyfile(join(src_dir, 'Makefile'), 'Makefile')

    def append(self, var, val):
        self.env[var] = self.env.get(var, '') + ' ' + val

    def prefer(self, cmd, preferred):
        if exe_available(preferred):
            self.env[cmd] = preferred
        else:
            stderr.write('warning: %s not found, using default %s\n' % (preferred, cmd))
